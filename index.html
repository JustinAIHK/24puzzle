<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>24 Puzzle Game</title>
  <style>
    .puzzle-container {
      max-width: 600px;
      margin: 0 auto;
      text-align: center;
    }
    .puzzle-cell {
      background: #0073aa;
      color: white;
      padding: 15px;
      text-align: center;
      border-radius: 4px;
      font-weight: bold;
    }
    .puzzle-cell.empty {
      background: #f0f0f1;
    }
    .controls button {
      padding: 10px 20px;
      background: #0073aa;
      color: white;
      border: none;
      cursor: pointer;
      margin: 5px;
    }
    .controls button#auto-sort-btn {
      background: #28a745;
    }
    .controls button#reset-btn {
      background: #dc3545;
    }
    #game-grid {
      display: grid;
      grid-template-columns: repeat(5, 50px);
      gap: 5px;
      margin: 20px auto;
      justify-content: center;
    }
  </style>
</head>
<body>
  <div class="puzzle-container">
    <h2 style="color: #333;">24 Puzzle Game</h2>
    <div id="game-grid"></div>
    <div class="controls">
      <button id="start-btn">Start Game</button>
      <button id="auto-sort-btn">Auto Sort</button>
      <button id="reset-btn" style="display: none;">Reset Game (R)</button>
    </div>
    <div style="text-align: center; margin-top: 15px;">
      Time: <span id="game-timer">00:00</span>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function () {
      let grid = [],
        emptyRow = 4,
        emptyCol = 4,
        timerInterval,
        startTime,
        isAutoSorting = false;
      let initialGrid = [];
      let initialEmptyRow, initialEmptyCol;
      let shuffleMoves = [];

      // Initialize the game grid in a shuffled state
      function initGame() {
        grid = [];
        let num = 1;
        for (let i = 0; i < 5; i++) {
          let row = [];
          for (let j = 0; j < 5; j++) {
            row.push((i === 4 && j === 4) ? 0 : num++);
          }
          grid.push(row);
        }
        shuffleGrid();
        initialGrid = JSON.parse(JSON.stringify(grid));
        initialEmptyRow = emptyRow;
        initialEmptyCol = emptyCol;
        renderGrid();
      }

      // Shuffle the grid
      function shuffleGrid() {
        shuffleMoves = [];
        const directions = ['w', 's', 'a', 'd'];
        let validMoves = 0;

        while (validMoves < 100) {
          const dir = directions[Math.floor(Math.random() * directions.length)];
          if (move(dir, true)) {
            shuffleMoves.push(dir);
            validMoves++;
          }
        }
      }

      // Move tiles
      function move(dir, isShuffling = false) {
        let newRow = emptyRow;
        let newCol = emptyCol;

        if (dir === 'w' && emptyRow < 4) newRow++;
        else if (dir === 's' && emptyRow > 0) newRow--;
        else if (dir === 'a' && emptyCol < 4) newCol++;
        else if (dir === 'd' && emptyCol > 0) newCol--;

        if (newRow !== emptyRow || newCol !== emptyCol) {
          grid[emptyRow][emptyCol] = grid[newRow][newCol];
          grid[newRow][newCol] = 0;
          emptyRow = newRow;
          emptyCol = newCol;
          renderGrid();
          if (!isShuffling && checkWin()) {
            clearInterval(timerInterval);
            alert(`Congratulations! You solved the puzzle in ${document.getElementById('game-timer').textContent}!`);
          }
          return true;
        }
        return false;
      }

      // Auto-sort the puzzle (FIXED: Use a copy of shuffleMoves)
      function autoSort() {
        if (isAutoSorting) return;
        isAutoSorting = true;
        document.getElementById('auto-sort-btn').disabled = true;

        // Clone shuffleMoves to avoid modifying the original array
        const solveSequence = shuffleMoves.slice().reverse().map(move => {
          const reverseMoves = { 'w': 's', 's': 'w', 'a': 'd', 'd': 'a' };
          return reverseMoves[move];
        });

        let step = 0;
        const interval = setInterval(() => {
          if (step >= solveSequence.length) {
            clearInterval(interval);
            isAutoSorting = false;
            document.getElementById('auto-sort-btn').disabled = false;
            return;
          }
          move(solveSequence[step]);
          step++;
        }, 200);
      }

      // Reset the game (FIXED: Re-initialize shuffleMoves)
      function resetGame() {
        clearInterval(timerInterval);
        grid = JSON.parse(JSON.stringify(initialGrid));
        emptyRow = initialEmptyRow;
        emptyCol = initialEmptyCol;
        renderGrid();
        document.getElementById('game-timer').textContent = '00:00';
        document.getElementById('start-btn').style.display = 'inline-block';
        document.getElementById('auto-sort-btn').style.display = 'inline-block';
        document.getElementById('reset-btn').style.display = 'none';
      }


      // Start the game
      function startGame() {
        startTime = Date.now();
        timerInterval = setInterval(updateTimer, 1000);
        document.getElementById('start-btn').style.display = 'none';
        document.getElementById('auto-sort-btn').style.display = 'none';
        document.getElementById('reset-btn').style.display = 'inline-block';
      }

      // Event listeners
      document.getElementById('start-btn').addEventListener('click', startGame);
      document.getElementById('auto-sort-btn').addEventListener('click', () => {
        startGame();
        autoSort();
      });
      document.getElementById('reset-btn').addEventListener('click', resetGame);

      document.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        if (['w', 'a', 's', 'd'].includes(key)) {
          move(key);
        } else if (key === 'r') {
          resetGame();
        }
      });

      // Initialize the game on page load
      initGame();
    });
  </script>
</body>
</html>
